% This file was converted from the original Markdown file in the js-slang wiki
% using Pandoc with this command line:
% pandoc --no-highlight -f markdown-auto_identifiers -t latex
% The following adjustments were done to the resulting TeX:
% - Change verbatim environments to lstlisting
% - Remove \tightlist
% - Change longtable to tabular, and change the column spec to {ll}
% - Remove \endhead (a longtable thing)

\input source_header.tex
\usepackage{booktabs}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
            {-3.25ex\@plus -1ex \@minus -.2ex}%
            {1.5ex \@plus .2ex}%
            {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{5}{\z@}%
            {-3.25ex\@plus -1ex \@minus -.2ex}%
            {1.5ex \@plus .2ex}%
            {\normalfont\normalsize\bfseries}}
\makeatother

\author{koo}
\date{\today}
\title{Source Virtual Machine Language}
\hypersetup{
 pdfauthor={koo},
 pdflang={English}}

\renewcommand{\docheader}[3]{%

  \thispagestyle{empty}

\markright{SICP, JavaScript Adaptation, #2 #3, #1}
\begin{center}
  {\Large {\bf Specification of #2 #3}---#1 edition}\\[10mm]

  {\large Tee Hao Wei}\\[5mm]

  {\large National University of Singapore \\
          School of Computing}\\[10mm]

  {\large \today}\\[10mm]
\end{center}
}
\begin{document}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\docheader{2021}{Source}{Virtual Machine Language}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input source_intro.tex

\tableofcontents

\section{Source Virtual Machine Language}

The Source Virtual Machine Language defines a virtual machine with a set of instructions,
and an associated JSON assembly and binary format.

It is intended as a compilation target for the Source language that is suitable
not only for efficient execution on normal PCs, but also low-power machines like
microcontrollers (e.g. Arduino).

\subsection{VM structure}

\subsubsection{Function definitions}

All code in an SVM program exists within functions. A function (distinct
from a function value) consists of

\begin{itemize}
\item
  the stack size for the function (number of entries)
\item
  the environment size for the function (number of entries)
\item
  the number of arguments expected by the function, which must be less
  than or equal to the environment size for the function
\item
  the function's code
\end{itemize}

\subsubsection{Programs}

An SVM program consists of functions. One function is designated as the
entry point of the program.

\subsubsection{Execution}

Execution of a program begins by calling the entry point with zero
arguments. The result of the program is then the value returned from the
entry point function. (This avoids having special instructions to start
and end a program.)

Instructions are executed sequentially, unless an instruction that
transfers execution to another location in the program is executed.

\paragraph{Calling convention}

Functions are called using the \texttt{call} or \texttt{call.t}
instructions. When a function is called,

\begin{enumerate}
\item
  the arguments are popped off the caller's stack, as detailed in the
  entries for the \texttt{call} and \texttt{call.t} instructions
\item
  a new frame is created, based on the information in the function's
  header
\item
  the arguments passed by the caller are inserted into the new
  environment, with the first argument in slot 0 of the environment, the
  second in slot 1, and so on
\item
  execution is transferred to the first instruction of the function
\end{enumerate}

When a function returns,

\begin{enumerate}
\item
  the function's return value is pushed onto the stack of the caller, as
  detailed in the entries for the \texttt{call} and \texttt{call.t}
  instructions
\item
  execution returns to the instruction in the caller immediately after
  the \texttt{call} or \texttt{call.t} instruction
\end{enumerate}

\paragraph{Faults}

Some instructions may produce faults. When a fault occurs, execution
halts.

Implementations are recommended to track the reason for a fault, and
provide some mechanism for debugging a fault (such as providing a stack
trace, etc).

Faults are documented within each instruction's entry.

\subsubsection{Frames}

A frame consists of an operand stack (hereafter referred to as just a
stack) and an environment.

A frame is created each time a function is called. When the function
returns, its stack is destroyed; its environment may persist if there
are new function values created that refer to its environment as their
parent environment.

\paragraph{Values in stacks and environments}

All SVM instructions do one of the following:

\begin{itemize}
\item
  load values from an environment onto the executing function's
  environment
\item
  store values into an environment from the stack
\item
  operate on values on the stack only
\end{itemize}

All values on stacks and in environments are either booleans, numbers,
or boxed values (which may be any of the 7 SVM types, including booleans
or numbers). Implementations are not required to be able to
differentiate booleans, numbers or boxed values on stacks and in
environments, but are required to track the types of values stored
within a boxed value; this is required to implement instructions such as
\texttt{add.g} that depend on the actual types of their operands.

\paragraph{Stack}

A stack is used to store intermediate results and pass operands to
instructions.

When a function is called, an empty stack is created with size as
specified in the function's header.

Stacks are accessed in a strictly LIFO manner; all instructions only
push or pop from the top of the executing function's stack.

\paragraph{Environment}

An environment is used to store local variables and function arguments.

When a function is called, a environment is created with size as
specified in the function's header. The arguments passed to the function
are placed in the first slots in the environment, with the first
argument in slot 0, the second in slot 1, and so on.

Environments are accessed only by the \texttt{ldl}, \texttt{ldp},
\texttt{stl} and \texttt{stp} instruction families, which load and store
values in environments.

\subsubsection{Data types}

The SVM recognises these distinct types:

\begin{itemize}
\item
  undefined, a singleton
\item
  null, also a singleton
\item
  boolean, either \texttt{true} or \texttt{false}
\item
  number
\item
  string
\item
  array
\item
  function
\end{itemize}

\paragraph{Numbers}

Implementations are recommended to implement number semantics following
the IEEE 754 double-precision floating point specification where
possible. As an allowance for platforms for which this would be too
expensive, implementations may implement number semantics following the
single-precision floating point specification instead.

\paragraph{Strings}

Strings are arbitrary sequences of bytes (including the zero byte). SVM
defines no operations on strings other than concatenation, so character
encoding does not affect SVM string semantics.

\paragraph{Arrays}

Arrays are maps from non-negative integer numbers (indexes) to any
value. Loading an unassigned index results in \texttt{undefined}.

Arrays have a \texttt{length} property, accessed by the primitive
function \texttt{array\_length}, that returns one plus the highest index
that has been assigned to, or 0 if no index has been assigned to.

Note: assigning \texttt{undefined} to an array index is
indistinguishable except for the effect of the assignment on the array's
\texttt{length}.

\paragraph{Function values}

A function value is a tuple consisting of a pointer to the function's
location in the program, and the environment in which the function value
was created.

\subsection{\texorpdfstring{\href{SVML-Instruction-Set}{Instruction
set}}{Instruction set}}

(click on the link)

\subsection{Program representations}

There are two standard representations of a SVML program. VM
implementations are free to accept the representation that works best
for them.

\subsubsection{JSON assembly format}

A program is an array consisting of two values:

\begin{itemize}
\item
  the index of the entry point function in the following array
\item
  an array of functions
\end{itemize}

A function is an array consisting of four values:

\begin{itemize}
\item
  the stack size for the function, as a number
\item
  the environment size for the function, as a number
\item
  the number of arguments expected by the function, as a number
\item
  the function's code, an array of instructions
\end{itemize}

An instruction is an array consisting of:

\begin{itemize}
\item
  the opcode in position 0
\item
  any arguments which may include numbers, boolean values, or strings
\end{itemize}

For instructions \texttt{new.c} and \texttt{jmp} which take
\texttt{\textless{}address\textgreater{}}es, an array consisting of the
following is specified instead:

\begin{itemize}
\item
  the index of the function
\item
  the index of the instruction in the function (for \texttt{jmp};
  ignored and optional for \texttt{new.c})
\end{itemize}

For instructions \texttt{br.t} and \texttt{br} which take
\texttt{\textless{}offset\textgreater{}}s, a number specifying the
number of \emph{instructions} to skip is specified instead.

As a TypeScript type definition:

\begin{lstlisting}
type Offset = number; // instructions to skip
type Address = [
    number, // function index
    Offset  // instruction index within function; optional
];
type Instruction = [
    number,                     // opcode
    number | boolean | string | // arguments
        Offset | Address
];
type SVMFunction = [
    number,         // stack size
    number,         // environment size
    number,         // number of arguments
    Instruction[]   // code
];
type Program = [
    number,         // index of entry point function
    SVMFunction[]
];
\end{lstlisting}

\subsubsection{Binary format}

\begin{itemize}
\item
  There is no padding between any values unless explicitly specified.
\item
  All instruction opcodes are one byte long.
\item
  All values are in little-endian.
\item
  We use the integer and float type names from Rust to denote operand
  types in instruction entries.

  \begin{itemize}
    \item
    E.g. \texttt{u8} refers to an 8-bit unsigned integer; \texttt{i32}
    refers to a 32-bit signed integer; \texttt{f32} refers to a 32-bit
    (single-precision) floating point.
  \end{itemize}
\item
  An \texttt{address} is a 32-bit unsigned integer \texttt{u32} that
  refers to an offset from the start of the program.
\item
  An \texttt{offset} is a 32-bit signed integer \texttt{u8} that refers
  to an offset from the start of the \emph{next} instruction.
\item
  A structure \emph{aligned to N bytes} means:

  \begin{itemize}
    \item
    if \texttt{address\ \%\ N\ ==\ 0}, then the structure may begin
    there
  \item
    otherwise, skip \texttt{N\ -\ address\ \%\ N} bytes, and then begin
    the structure
  \end{itemize}
\end{itemize}

A program is a \texttt{Program}.

\paragraph{\texorpdfstring{\texttt{Program}
structure}{Program structure}}

\begin{tabular}{ll}
\toprule
Field & Type\tabularnewline
\midrule
Header & \texttt{Header}\tabularnewline
Constant & \texttt{Constant{[}{]}}\tabularnewline
Alignment & to 4 bytes\tabularnewline
Functions & \texttt{Function{[}{]}}\tabularnewline
\bottomrule
\end{tabular}

\medskip

Each \texttt{Constant} and \texttt{Function} is aligned to 4 bytes.

\paragraph{\texorpdfstring{\texttt{Header} structure}{Header structure}}

\begin{tabular}{ll}
\toprule
Field & Type\tabularnewline
\midrule
Magic & \texttt{u32}\tabularnewline
Major version & \texttt{u16}\tabularnewline
Minor version & \texttt{u16}\tabularnewline
Entry point & \texttt{address}\tabularnewline
Constant pool count & \texttt{u32}\tabularnewline
\bottomrule
\end{tabular}

\begin{itemize}
\item
  Magic is the value \texttt{0x5005ACAD}
\item
  The entry point must point to a \texttt{Function}
\end{itemize}

\texttt{Header} is 16 bytes.

\paragraph{\texorpdfstring{\texttt{Constant}
structure}{Constant structure}}

Each \texttt{Constant} should be aligned to 4 bytes.

\medskip

\begin{tabular}{ll}
\toprule
Field & Type\tabularnewline
\midrule
Type & \texttt{u16}\tabularnewline
Length & \texttt{u32}\tabularnewline
Data & Depends on type\tabularnewline
\bottomrule
\end{tabular}

\medskip

\texttt{Constant} is \texttt{6\ +\ Length} bytes.

\subparagraph{\texorpdfstring{String (type
\texttt{1})}{String (type 1)}}

\begin{tabular}{ll}
\toprule
Field & Type\tabularnewline
\midrule
Data & \texttt{u8{[}{]}}\tabularnewline
\bottomrule
\end{tabular}

\begin{itemize}
\item
  The length of Data is equal to Length in the constant header.
\end{itemize}

\paragraph{\texorpdfstring{\texttt{Function}
structure}{Function structure}}

Each \texttt{Function} should be aligned to 4 bytes.

\medskip

\begin{tabular}{ll}
\toprule
Field & Type\tabularnewline
\midrule
Stack size & \texttt{u8}\tabularnewline
Environment size & \texttt{u8}\tabularnewline
Number of arguments & \texttt{u8}\tabularnewline
Padding (alignment) & \texttt{u8}\tabularnewline
Code & \texttt{Instruction{[}{]}}\tabularnewline
\bottomrule
\end{tabular}

\paragraph{\texorpdfstring{\texttt{Instruction}
structure}{Instruction structure}}

An instruction consists of the \texttt{u8} opcode plus any arguments.
There is no padding or alignment between arguments. Instructions are
concatenated with no padding or alignment between instructions.

For example, the following instructions

\begin{verbatim}
ldc.i 123
pop.f
\end{verbatim}

should result in the following (hex) bytes:

\begin{verbatim}
01 7B 00 00 00 10
\end{verbatim}
\end{document}
